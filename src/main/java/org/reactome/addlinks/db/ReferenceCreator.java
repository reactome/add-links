package org.reactome.addlinks.db;

import java.util.Collection;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.gk.database.DefaultInstanceEditHelper;
import org.gk.model.GKInstance;
import org.gk.model.InstanceDisplayNameGenerator;
import org.gk.model.ReactomeJavaConstants;
import org.gk.persistence.MySQLAdaptor;
import org.gk.schema.GKSchemaAttribute;
import org.gk.schema.InvalidAttributeException;
import org.gk.schema.InvalidAttributeValueException;
import org.gk.schema.SchemaClass;
import org.gk.util.GKApplicationUtilities;

public class ReferenceCreator
{
	private static final Logger logger = LogManager.getLogger();

	Collection<GKInstance> identifiers;

	//The class of the Reference we will create.
	private SchemaClass schemaClass;
	
	//The class of the thing we will refer to with this new Reference.
	private SchemaClass referringToSchemaClass;

	//The attribute on referringToSchemaClass that will refer to the Reference we will create.
	private GKSchemaAttribute referringAttribute;
	
	private MySQLAdaptor dbAdapter;

	//TODO: Re-organize this class. It is poorly designed. Options:
	// - just static methods to create References
	// - more specific subclasses fill in the details of the different SchemaClasses
	//   - through concrete subclasses or instances created with Spring?
	// - ???
	
	/**
	 * 
	 * @param identifier - the Identifier from some other database.
	 * @param schemaClass - The Reactome Schema Class of the thing we will create, such as ReferenceDNASequence.
	 * @param adapter - an existing database adapter.
	 */
	public ReferenceCreator(String identifier, SchemaClass schemaClass, SchemaClass referringSchemaClass, GKSchemaAttribute referringAttribute, MySQLAdaptor adapter)
	{
		this.dbAdapter = adapter;
		this.schemaClass = schemaClass;
		this.referringToSchemaClass = referringSchemaClass;
		this.referringAttribute = referringAttribute;
//		try
//		{
//			GKSchemaAttribute identifierAttribute = (GKSchemaAttribute) this.schemaClass.getAttribute(ReactomeJavaConstants.identifier);
//			// Try to see if this Identifier is already in the database.
//			// Ideally, this will not return anything.
//			this.identifiers = (Collection<GKInstance>) this.dbAdapter.fetchInstanceByAttribute(identifierAttribute, "=", identifier);
//		} catch (Exception e)
//		{
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}

	}

	/**
	 * Creates an external Identifier in the database. 
	 * @param identifierValue - The Identifying string.
	 * @param referenceToValue - The DB ID of the pre-existing thing this Identifier identifiers. 
	 * @param refDB - The reference database that this Identifier comes from, such as FlyBase, HMDB, etc...
	 * @param personID - The ID of the Person who is creating this Identifier.
	 * @param creatorName - A string which identifiers the code that created this Identifier. 
	 * @throws Exception if anything goes wrong. 
	 */
	public void createIdentifier(String identifierValue, String referenceToValue, String refDB, long personID, String creatorName) throws Exception
	{
		
		// TODO: Need to rethink this: Attempt to create a cross reference. If
		// it already exists, print a warning and move on.
		// Normally, the references generated by AddLinks should NOT be in the
		// database, but because they never get
		// back-propagated from reactomerelease to reactomecurator, they need to
		// be re-created in every Release.
		// But since I don't have a database copy that contains orthoinferenced
		// entities but is missing the generated references
		// (and it's very complicated to figure out how to massage a
		// test_reactome_xx database to look the way it should),
		// I'll just code it to ignore pre-existing references. In theory, I
		// could add code to delete pre-existing references.
		// Also need to add an argument to help determine if the thing being
		// created is a DatabaseIdentifier, ReferenceGeneProduction,
		// ReferenceMolecule....

		// Before, purge all alt-db IDs so you have clean slate, make this
		// purging optional? Or check for pre-existing alt-db IDs...
		// For given uniprot ID, find referenced alt-db ID and if it already
		// exists and matches given ref val, do nothing.
		// other wise, create it.

		try
		{
			GKSchemaAttribute identifierAttribute = (GKSchemaAttribute) this.schemaClass.getAttribute(ReactomeJavaConstants.identifier);
			// Try to see if this Identifier is already in the database.
			// Ideally, this will not return anything.
			this.identifiers = (Collection<GKInstance>) this.dbAdapter.fetchInstanceByAttribute(identifierAttribute, "=", identifierValue);
		
			if (this.identifiers != null && this.identifiers.size() > 0)
			{
				// If the identifiers already exist, they should be deleted and
				// then re-added.
				for (GKInstance identifier : this.identifiers)
				{
					try
					{
						logger.warn( "Identifier {} already existed, but it shouldn't have. We will delete it so it can be added fresh.", identifier.getDisplayName());
						this.dbAdapter.deleteInstance(identifier);
					}
					catch (Exception e)
					{
						e.printStackTrace();
						throw e;
					}
				}
			}
			
			// Create a new instance of the necessary type.
			GKInstance identifierInstance = new GKInstance(this.schemaClass,null,this.dbAdapter);
			
			//logger.debug("Available attributes: {}", this.schemaClass.getAttributes());

			GKInstance instanceEdit = createInstanceEdit(personID, creatorName);
			//identifierInstance.addAttributeValue(attribute, identifierValue);
			// Need to create an InstanceEdit to track
			// the modifications.
			identifierInstance.addAttributeValue(ReactomeJavaConstants.created, instanceEdit);
			//this.dbAdapter.updateInstance(identifierInstance);
			
			//GKSchemaAttribute identifierAttribute = (GKSchemaAttribute) this.schemaClass.getAttribute(ReactomeJavaConstants.identifier);
			
			GKSchemaAttribute refDBAttribute = (GKSchemaAttribute) this.schemaClass.getAttribute(ReactomeJavaConstants.referenceDatabase);
			identifierInstance.addAttributeValue(identifierAttribute, identifierValue);
			GKInstance refDBInstance = getReferenceDatabase(refDB);
			identifierInstance.addAttributeValue(refDBAttribute, refDBInstance);
			//Save changes to the new Identifier.
			long newInstanceID = this.dbAdapter.storeInstance(identifierInstance);
			//...and then immediately grab it.
			GKInstance createdIdentifier = this.dbAdapter.fetchInstance(newInstanceID);
			this.dbAdapter.loadInstanceAttributeValues(createdIdentifier);
			//logger.debug(createdIdentifier);

			//Set up references between original RefGeneProduc and new RefDNASeq.
			GKInstance instanceReferredToByIdentifier = this.dbAdapter.fetchInstance(new Long(referenceToValue));
			//I think ReferenceGeneProduct should probably be parameterized here. Also, referenceGene.
			//SchemaClass refGeneProdClass = this.referringToSchemaClass; //this.dbAdapter.getSchema().getClassByName(ReactomeJavaConstants.ReferenceGeneProduct);
			GKSchemaAttribute xrefAttrib = this.referringAttribute; //(GKSchemaAttribute) refGeneProdClass.getAttribute(ReactomeJavaConstants.referenceGene);
			instanceReferredToByIdentifier.addAttributeValue(xrefAttrib, createdIdentifier);
			this.dbAdapter.updateInstance(instanceReferredToByIdentifier);
		}
		catch (Exception e)
		{
			e.printStackTrace();
			throw e;
		}
	
	}

	/**
	 * A helper method to get a ReferenceDatabase instance for the specified
	 * instance.
	 * 
	 * @param dbName
	 * @return
	 * @throws Exception
	 */
	protected GKInstance getReferenceDatabase(String dbName) throws Exception
	{
		// Using _displayName can fetch local shell instances.
		Collection<?> list = this.dbAdapter.fetchInstanceByAttribute(ReactomeJavaConstants.ReferenceDatabase, ReactomeJavaConstants._displayName, "=", dbName);
		GKInstance refDb = null;
		
		if (list.size() > 0)
		{
			refDb = (GKInstance) list.iterator().next();
		}
		return refDb;
	}

	private GKInstance createInstanceEdit(long personID, String creatorName)
	{
		GKInstance instanceEdit = null;
		try
		{
			instanceEdit = createDefaultIE(this.dbAdapter, personID, true);
			instanceEdit.getDBID();
			instanceEdit.setAttributeValue(ReactomeJavaConstants.note, "crossReference inserted by " + creatorName);
			this.dbAdapter.updateInstance(instanceEdit);
		}
		catch (InvalidAttributeException e)
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		catch (InvalidAttributeValueException e)
		{
			
			e.printStackTrace();
		}
		catch (Exception e)
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		return instanceEdit;
	}

	private static GKInstance createDefaultIE(MySQLAdaptor dba, Long defaultPersonId, boolean needStore) throws Exception
	{
		GKInstance defaultPerson = dba.fetchInstance(defaultPersonId);
		if (defaultPerson != null)
		{
			DefaultInstanceEditHelper ieHelper = new DefaultInstanceEditHelper();
			GKInstance newIE = ieHelper.createDefaultInstanceEdit(defaultPerson);
			newIE.addAttributeValue(ReactomeJavaConstants.dateTime, GKApplicationUtilities.getDateTime());
			InstanceDisplayNameGenerator.setDisplayName(newIE);
			if (needStore)
			{
				dba.storeInstance(newIE);
			}
			return newIE;
		}
		else
		{
			throw new Exception("Could not fetch Person entity with ID " + defaultPersonId + ". Please check that a Person entity exists in the database with this ID.");
		}
	}

	public void setSchemaClass(SchemaClass schemaClass)
	{
		this.schemaClass = schemaClass;
	}

	public void setReferringToSchemaClass(SchemaClass referringToSchemaClass)
	{
		this.referringToSchemaClass = referringToSchemaClass;
	}

	public void setReferringAttribute(GKSchemaAttribute referringAttribute)
	{
		this.referringAttribute = referringAttribute;
	}
}
