package org.reactome.addlinks.db;

import java.util.Collection;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.gk.database.DefaultInstanceEditHelper;
import org.gk.model.GKInstance;
import org.gk.model.InstanceDisplayNameGenerator;
import org.gk.model.ReactomeJavaConstants;
import org.gk.persistence.MySQLAdaptor;
import org.gk.schema.GKSchemaAttribute;
import org.gk.schema.InvalidAttributeException;
import org.gk.schema.InvalidAttributeValueException;
import org.gk.schema.SchemaClass;
import org.gk.util.GKApplicationUtilities;

public class ReferenceCreator
{
	private static final Logger logger = LogManager.getLogger();

	Collection<GKInstance> identifiers;

	private SchemaClass schemaClass;

	private MySQLAdaptor dbAdapter;

	/**
	 * 
	 * @param identifier
	 *            - the Identifier from some other database.
	 * @param adapter
	 *            - an existing database adapter.
	 */
	public ReferenceCreator(String identifier, SchemaClass schemaClass, MySQLAdaptor adapter)
	{
		this.dbAdapter = adapter;
		//this.schemaClass = adapter.getSchema().getClassByName(ReactomeJavaConstants.ReferenceDNASequence);
		this.schemaClass = schemaClass;
		try
		{
			GKSchemaAttribute attribute = (GKSchemaAttribute) this.schemaClass.getAttribute(ReactomeJavaConstants.identifier);
			// Try to see if this Identifier is already in the database.
			// Ideally, this will not return anything.
			this.identifiers = (Collection<GKInstance>) this.dbAdapter.fetchInstanceByAttribute(attribute, "=", identifier);
		} catch (Exception e)
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

	public void createIdentifier(String identifierValue, String referenceToValue, String refDB, long personID, String creatorName)
	{
		// TODO: Need to rethink this: Attempt to create a cross reference. If
		// it already exists, print a warning and move on.
		// Normally, the references generated by AddLinks should NOT be in the
		// database, but because they never get
		// back-propagated from reactomerelease to reactomecurator, they need to
		// be re-created in every Release.
		// But since I don't have a database copy that contains orthoinferenced
		// entities but is missing the generated references
		// (and it's very complicated to figure out how to massage a
		// test_reactome_xx database to look the way it should),
		// I'll just code it to ignore pre-existing references. In theory, I
		// could add code to delete pre-existing references.
		// Also need to add an argument to help determine if the thing being
		// created is a DatabaseIdentifier, ReferenceGeneProduction,
		// ReferenceMolecule....

		// Before, purge all alt-db IDs so you have clean slate, make this
		// purging optional? Or check for pre-existing alt-db IDs...
		// For given uniprot ID, find referenced alt-db ID and if it already
		// exists and matches given ref val, do nothing.
		// other wise, create it.

		if (this.identifiers != null && this.identifiers.size() > 0)
		{
			// If the identifiers already exist, they should be deleted and
			// then re-added.
			for (GKInstance identifier : this.identifiers)
			{
				try
				{
					logger.warn( "Identifier {} already existed, but it shouldn't have. We will delete it so it can be added fresh.", identifier.getDisplayName());
					this.dbAdapter.deleteInstance(identifier);
				}
				catch (Exception e)
				{
					e.printStackTrace();
				}
			}
		}
		
		// Create a new instance of the necessary type.
		GKInstance identifierInstance = new GKInstance(this.schemaClass,null,this.dbAdapter);
		
		//logger.debug("Available attributes: {}", this.schemaClass.getAttributes());
		
		try
		{
			GKInstance instanceEdit = createInstanceEdit(personID, creatorName);
			//identifierInstance.addAttributeValue(attribute, identifierValue);
			// Need to create an InstanceEdit to track
			// the modifications.
			identifierInstance.addAttributeValue(ReactomeJavaConstants.created, instanceEdit);
			//this.dbAdapter.updateInstance(identifierInstance);
			
			GKSchemaAttribute identifierAttribute = (GKSchemaAttribute) this.schemaClass.getAttribute(ReactomeJavaConstants.identifier);
			
			GKSchemaAttribute refDBAttribute = (GKSchemaAttribute) this.schemaClass.getAttribute(ReactomeJavaConstants.referenceDatabase);
			identifierInstance.addAttributeValue(identifierAttribute, identifierValue);
			GKInstance refDBInstance = getReferenceDatabase(refDB);
			identifierInstance.addAttributeValue(refDBAttribute, refDBInstance);
			//Save changes to the new Identifier.
			long newInstanceID = this.dbAdapter.storeInstance(identifierInstance);
			//...and then immediately grab it.
			GKInstance createdIdentifier = this.dbAdapter.fetchInstance(newInstanceID);
			this.dbAdapter.loadInstanceAttributeValues(createdIdentifier);
			//logger.debug(createdIdentifier);

			//Set up references between original RefGeneProduc and new RefDNASeq.
			GKInstance instanceReferredToByIdentifier = this.dbAdapter.fetchInstance(new Long(referenceToValue));
			SchemaClass refGeneProdClass = this.dbAdapter.getSchema().getClassByName(ReactomeJavaConstants.ReferenceGeneProduct);
			GKSchemaAttribute xrefAttrib = (GKSchemaAttribute) refGeneProdClass.getAttribute(ReactomeJavaConstants.referenceGene);
			instanceReferredToByIdentifier.addAttributeValue(xrefAttrib, createdIdentifier);
			this.dbAdapter.updateInstance(instanceReferredToByIdentifier);
		}
		catch (Exception e)
		{
			e.printStackTrace();
		}
	
	}

	/**
	 * A helper method to get a ReferenceDatabase instance for the specified
	 * instance.
	 * 
	 * @param dbName
	 * @return
	 * @throws Exception
	 */
	protected GKInstance getReferenceDatabase(String dbName) throws Exception
	{
		// Using _displayName can fetch local shell instances.
		Collection<?> list = this.dbAdapter.fetchInstanceByAttribute(ReactomeJavaConstants.ReferenceDatabase, ReactomeJavaConstants._displayName, "=", dbName);
		GKInstance refDb = null;
		
		if (list.size() > 0)
		{
			refDb = (GKInstance) list.iterator().next();
		}
		return refDb;
	}

	private GKInstance createInstanceEdit(long personID, String creatorName)
	{
		GKInstance instanceEdit = null;
		try
		{
			instanceEdit = createDefaultIE(this.dbAdapter, personID, true);
			instanceEdit.getDBID();
			instanceEdit.setAttributeValue(ReactomeJavaConstants.note, "crossReference inserted by " + creatorName);
			this.dbAdapter.updateInstance(instanceEdit);
		}
		catch (InvalidAttributeException e)
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		catch (InvalidAttributeValueException e)
		{
			
			e.printStackTrace();
		}
		catch (Exception e)
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		return instanceEdit;
	}

	private static GKInstance createDefaultIE(MySQLAdaptor dba, Long defaultPersonId, boolean needStore) throws Exception
	{
		GKInstance defaultPerson = dba.fetchInstance(defaultPersonId);
		if (defaultPerson != null)
		{
			DefaultInstanceEditHelper ieHelper = new DefaultInstanceEditHelper();
			GKInstance newIE = ieHelper.createDefaultInstanceEdit(defaultPerson);
			newIE.addAttributeValue(ReactomeJavaConstants.dateTime, GKApplicationUtilities.getDateTime());
			InstanceDisplayNameGenerator.setDisplayName(newIE);
			if (needStore)
			{
				dba.storeInstance(newIE);
			}
			return newIE;
		}
		else
		{
			throw new Exception("Could not fetch Person entity with ID " + defaultPersonId + ". Please check that a Person entity exists in the database with this ID.");
		}
	}

	public void setSchemaClass(SchemaClass schemaClass)
	{
		this.schemaClass = schemaClass;
	}
}
